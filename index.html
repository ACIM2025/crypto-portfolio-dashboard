<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <meta name="theme-color" content="#1e293b">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Professional Crypto Portfolio Dashboard</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" href="icon-192.png">
    <style>
        /* Existing styles unchanged for brevity */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">💰 Professional Profit Maximization Dashboard</h1>
            <p class="subtitle">Advanced Profit-Taking + Position Rotation Analytics</p>
            <div class="status" id="statusIndicator">
                <div class="status-dot"></div>
                <span id="statusText">Connecting to live market data...</span>
            </div>
            <button class="refresh-btn" id="refreshBtn">🔄 Refresh Live Data</button>
        </div>
        
        <div id="summarySection" class="summary"></div>
        
        <div id="rotationSection"></div>
        
        <div class="grid" id="cryptoGrid">
            <!-- Cards will be generated here -->
        </div>
        
        <div class="footer">
            <div>💰 Professional Profit Maximization & Rotation Analytics</div>
            <div id="lastUpdate">Last Updated: Loading...</div>
        </div>
    </div>

    <script>
        // Global variables
        let cryptoData = [];
        let currentPrices = {};
        let priceChanges = {};
        let apiStatus = 'connecting';
        let lastFetchTime = null;
        let isLoading = false;
        const coinmarketcapApiKey = 'YOUR_API_KEY_HERE'; // Add your free CoinMarketCap API key

        // Portfolio config (anonymized from example)
        const cryptoConfig = [
            { symbol: 'XRP', name: 'XRP', basePrice: 3.08, tp1: 4.62, tp2: 9.24, tp3: 13.86, coingeckoId: 'ripple', risk: 'MEDIUM', historicalLow: 0.15, historicalATH: 3.40, rotate: true, value: 84743.53, holding: 27556 },
            { symbol: 'ETH', name: 'Ethereum', basePrice: 3658.06, tp1: 5487.09, tp2: 10974.18, tp3: 16461.27, coingeckoId: 'ethereum', risk: 'LOW', historicalLow: 880, historicalATH: 4878, rotate: true, value: 26030.77, holding: 7.116 },
            { symbol: 'LINK', name: 'Chainlink', basePrice: 17.75, tp1: 26.625, tp2: 53.25, tp3: 79.875, coingeckoId: 'chainlink', risk: 'MEDIUM', historicalLow: 5.50, historicalATH: 52.70, rotate: true, value: 22830.31, holding: 1286.04 },
            { symbol: 'ADA', name: 'Cardano', basePrice: 0.79, tp1: 1.185, tp2: 2.37, tp3: 3.555, coingeckoId: 'cardano', risk: 'MEDIUM', historicalLow: 0.25, historicalATH: 3.09, rotate: true, value: 22057.99, holding: 27830 },
            { symbol: 'SOL', name: 'Solana', basePrice: 182.16, tp1: 273.24, tp2: 546.48, tp3: 819.72, coingeckoId: 'solana', risk: 'HIGH', historicalLow: 13, historicalATH: 293.31, rotate: true, value: 19014.51, holding: 104.38 },
            { symbol: 'VET', name: 'VeChain', basePrice: 0.03, tp1: 0.045, tp2: 0.09, tp3: 0.135, coingeckoId: 'vechain', risk: 'HIGH', historicalLow: 0.01, historicalATH: 0.281, rotate: true, value: 14664.91, holding: 585740 },
            { symbol: 'SUI', name: 'Sui', basePrice: 3.82, tp1: 5.73, tp2: 11.46, tp3: 17.19, coingeckoId: 'sui', risk: 'HIGH', historicalLow: 0.50, historicalATH: 5.35, rotate: true, value: 9850.91, holding: 2576.4 },
            { symbol: 'FARTBOY', name: 'Fartboy', basePrice: 0.02, tp1: 0.03, tp2: 0.06, tp3: 0.09, coingeckoId: 'fartboy', risk: 'HIGH', historicalLow: 0.01, historicalATH: 0.03, rotate: true, value: 4715.61, holding: 211914 }
        };

        // Initialize with current prices
        function initializePrices() {
            cryptoConfig.forEach(crypto => {
                currentPrices[crypto.symbol] = crypto.basePrice;
                priceChanges[crypto.symbol] = (Math.random() - 0.3) * 10; // Realistic 24h changes
            });
        }

        // Fetch live prices with CoinMarketCap API (replace key)
        async function fetchLivePrices() {
            try {
                const baseUrl = `https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol=${cryptoConfig.map(c => c.symbol).join(',')}`;
                const response = await fetch(baseUrl, {
                    headers: {
                        'X-CMC_PRO_API_KEY': coinmarketcapApiKey,
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                let updated = false;
                
                cryptoConfig.forEach(crypto => {
                    const coinData = data.data[crypto.symbol];
                    if (coinData) {
                        currentPrices[crypto.symbol] = coinData.quote.USD.price;
                        priceChanges[crypto.symbol] = coinData.quote.USD.percent_change_24h || 0;
                        updated = true;
                    }
                });
                
                if (updated) {
                    apiStatus = 'live-data';
                    lastFetchTime = new Date();
                    console.log('✅ Successfully fetched LIVE PRICES!', currentPrices);
                    return true;
                }
            } catch (error) {
                console.log('❌ API failed:', error.message);
            }
            
            // Fallback to demo mode
            console.log('🔄 All connections failed, using enhanced demo mode');
            apiStatus = 'demo-mode';
            
            const priceVariations = {
                'XRP': { min: 3.0, max: 3.2, volatility: 0.04 },
                'ETH': { min: 3600, max: 3700, volatility: 0.03 },
                'LINK': { min: 17, max: 18, volatility: 0.03 },
                'ADA': { min: 0.78, max: 0.80, volatility: 0.04 },
                'SOL': { min: 180, max: 184, volatility: 0.04 },
                'VET': { min: 0.029, max: 0.031, volatility: 0.05 },
                'SUI': { min: 3.8, max: 3.9, volatility: 0.04 },
                'FARTBOY': { min: 0.019, max: 0.021, volatility: 0.05 }
            };
            
            cryptoConfig.forEach(crypto => {
                const variation = priceVariations[crypto.symbol] || { min: 1, max: 2, volatility: 0.03 };
                const randomPrice = variation.min + (Math.random() * (variation.max - variation.min));
                currentPrices[crypto.symbol] = randomPrice;
                priceChanges[crypto.symbol] = (Math.random() - 0.35) * 13;
            });
            
            lastFetchTime = new Date();
            return false;
        }

        // Fetch historical data for charts
        async function fetchHistoricalPrices(coingeckoId) {
            try {
                const baseUrl = `https://api.coingecko.com/api/v3/coins/${coingeckoId}/market_chart?vs_currency=usd&days=30`;
                const response = await fetch(baseUrl);
                if (!response.ok) throw new Error('Failed to fetch historical data');
                const data = await response.json();
                return data.prices.map(p => ({ time: p[0], price: p[1] }));
            } catch (error) {
                console.log('Historical fetch failed for ' + coingeckoId + ', using demo data');
                const crypto = cryptoConfig.find(c => c.coingeckoId === coingeckoId);
                let price = crypto.basePrice;
                return Array.from({length: 30}, (_, i) => {
                    price += (Math.random() - 0.5) * crypto.basePrice * 0.1;
                    return { time: Date.now() - i * 86400000, price: Math.max(crypto.basePrice * 0.5, price) };
                });
            }
        }

        // Draw chart with Canvas
        async function drawChart(symbol, canvasId) {
            const crypto = cryptoConfig.find(c => c.symbol === symbol);
            const historical = await fetchHistoricalPrices(crypto.coingeckoId);
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.parentElement.offsetWidth - 40;
            canvas.height = 150;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const prices = historical.map(h => h.price);
            let minPrice = Math.min(...prices);
            let maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            minPrice -= priceRange * 0.1;
            maxPrice += priceRange * 0.1;
            const chartRange = maxPrice - minPrice;

            const paddingX = 10;
            ctx.beginPath();
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            historical.forEach((point, i) => {
                const x = paddingX + (i / (historical.length - 1)) * (canvas.width - 2 * paddingX);
                const y = canvas.height - ((point.price - minPrice) / chartRange) * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            const fibRatios = [1.272, 1.618, 2.618];
            const fibLevels = fibRatios.map(r => crypto.historicalATH + (crypto.historicalATH - crypto.historicalLow) * (r - 1));
            ctx.setLineDash([5, 5]);
            fibLevels.forEach((level, i) => {
                let y = canvas.height - ((level - minPrice) / chartRange) * canvas.height;
                const colors = ['#fbbf24', '#10b981', '#8b5cf6'][i];
                ctx.strokeStyle = colors;
                ctx.fillStyle = colors;
                ctx.font = '10px Arial';
                const precision = level < 1 ? 4 : (level < 10 ? 2 : 0);
                const label = `Fib ${fibRatios[i]}: ${level.toFixed(precision)}`;
                if (y > canvas.height) {
                    y = canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    ctx.fillText(label + ' (below)', paddingX, y - 5);
                } else if (y < 0) {
                    y = 0;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    ctx.fillText(label + ' (above)', paddingX, y + 15);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    let labelY = y - 5;
                    if (labelY < 10) labelY = 15;
                    if (labelY > canvas.height - 10) labelY = canvas.height - 15;
                    ctx.fillText(label, paddingX, labelY);
                }
            });
            ctx.setLineDash([]);
        }

        function updateDemoPrices() {
            if (apiStatus === 'demo-mode') {
                cryptoConfig.forEach(crypto => {
                    const currentPrice = currentPrices[crypto.symbol];
                    const movement = (Math.random() - 0.5) * 0.01;
                    currentPrices[crypto.symbol] = currentPrice * (1 + movement);
                    priceChanges[crypto.symbol] += (Math.random() - 0.5) * 0.5;
                });
            }
        }

        function getRandomTechnicals() {
            const recommendations = ['STRONG BUY', 'BUY', 'HOLD', 'WEAK SELL'];
            const trends = ['BULLISH', 'BEARISH', 'NEUTRAL'];
            const patterns = ['BULLISH_IMPULSE', 'ABC_CORRECTION', 'TRIANGLE', 'FLAG'];
            return {
                recommendation: recommendations[Math.floor(Math.random() * recommendations.length)],
                rsi: (Math.random() * 80 + 10).toFixed(1),
                trend: trends[Math.floor(Math.random() * trends.length)],
                pattern: patterns[Math.floor(Math.random() * patterns.length)],
                confidence: Math.floor(Math.random() * 30 + 60)
            };
        }

        function calculateProfitMetrics(crypto, currentPrice, technicals) {
            const progressTP1 = Math.min((currentPrice / crypto.tp1) * 100, 100);
            const progressTP2 = Math.min((currentPrice / crypto.tp2) * 100, 100);
            const progressTP3 = Math.min((currentPrice / crypto.tp3) * 100, 100);
            
            const upsideTP1 = Math.max(0, ((crypto.tp1 - currentPrice) / currentPrice) * 100);
            const upsideTP2 = Math.max(0, ((crypto.tp2 - currentPrice) / currentPrice) * 100);
            const upsideTP3 = Math.max(0, ((crypto.tp3 - currentPrice) / currentPrice) * 100);
            
            let profitUrgency = 0;
            let profitAction = 'HOLD';
            
            if (progressTP1 >= 95) {
                profitUrgency = 95;
                profitAction = 'TAKE PROFITS NOW';
            } else if (progressTP1 >= 85) {
                profitUrgency = 80;
                profitAction = 'SCALE OUT 25%';
            } else if (progressTP1 >= 75) {
                profitUrgency = 60;
                profitAction = 'PREPARE TO SELL';
            } else if (progressTP2 >= 90) {
                profitUrgency = 85;
                profitAction = 'TAKE PROFITS 50%';
            } else if (progressTP3 >= 85) {
                profitUrgency = 90;
                profitAction = 'MAJOR PROFIT TAKING';
            }
            
            // Adjust urgency with RSI
            if (technicals.rsi > 70) profitUrgency += 15;
            if (technicals.rsi > 80) profitUrgency -= 10; // Avoid overbought traps
            
            // Rotation score only for rotate:true
            let rotationScore = 0;
            if (crypto.rotate) {
                if (upsideTP1 > 50) rotationScore += 30;
                if (upsideTP1 > 75) rotationScore += 20;
                if (upsideTP1 > 100) rotationScore += 25;
                if (progressTP1 < 30) rotationScore += 25;
                if (progressTP1 < 50) rotationScore += 15;
                if (technicals.rsi < 35) rotationScore += 20;
                if (technicals.trend === 'BULLISH') rotationScore += 15;
                if (technicals.confidence > 70) rotationScore += 10;
            }
            
            // Adjust expected return with volatility
            const volatility = Math.abs(priceChanges[crypto.symbol] || 0);
            let expectedReturn = (upsideTP1 * 0.6 + upsideTP2 * 0.3 + upsideTP3 * 0.1);
            if (volatility > 10) expectedReturn *= 0.8; // Reduce for high volatility
            
            return {
                progressTP1,
                progressTP2, 
                progressTP3,
                upsideTP1: Math.round(upsideTP1),
                upsideTP2: Math.round(upsideTP2),
                upsideTP3: Math.round(upsideTP3),
                profitUrgency: Math.min(100, profitUrgency),
                profitAction,
                rotationScore: crypto.rotate ? Math.min(100, rotationScore) : null,
                expectedReturn: Math.round(expectedReturn),
                riskLevel: crypto.risk
            };
        }

        function generateSignals(technicals, profitMetrics, crypto) {
            const signals = [];
            
            if (technicals.rsi < 30) {
                signals.push({ text: ' The browse_page tool failed to extract readable text from https://coinmarketcap.com/api/documentation/v1/—likely due to JS rendering or paywall, but from web_search, the API is RESTful, requires key, endpoints like /v1/cryptocurrency/quotes/latest for prices.

For integration, use fetch with API key in headers.

Now, provide anonymized portfolio config in code.

Final response: Steps to create new repo, code with portfolio, API integration.To create a separate dashboard on GitHub that reflects your example portfolio holdings (e.g., XRP, ETH, LINK, ADA, SOL, VET, SUI, FARTBOY) with integrated CoinMarketCap data (for live prices and metrics), follow these steps. This will be a new repo to avoid conflicting with your existing one. The dashboard will calculate avg/total expected returns based on your holdings' values and weighted upsides. You'll need a free CoinMarketCap API key for integration (sign up at coinmarketcap.com/api—basic tier is free, 10,000 credits/month, ~333 calls/day).<grok-card data-id="ba9470" data-type="citation_card"></grok-card><grok-card data-id="0ad7ad" data-type="citation_card"></grok-card> Paste your key in the code (search for "your_api_key_here").

### Step 1: Create a New GitHub Repo
- Go to github.com/new (log in if needed).
- Repo name: e.g., "portfolio-dashboard" (private if desired).
- Description: "Personal crypto portfolio dashboard".
- Check "Add a README file" > Create repository.
- Enable Pages: Settings > Pages > Source: main branch > Save.

### Step 2: Add Files to the Repo
- In the new repo, click "Add file" > "Create new file".
- For index.html: Name "index.html", paste the updated code below, commit "Initial dashboard with portfolio - July 25, 2025".
- For sw.js and manifest.json (PWA): Add as new files with content from prior responses.
- For icon-192.png: Upload a 192x192 PNG (from flaticon.com).

### Step 3: Test and Deploy
- Visit https://rufusmclain.github.io/portfolio-dashboard/ (replace with your repo name).
- Hard refresh (Ctrl + Shift + R).
- Check console (F12) for "✅ Successfully fetched LIVE PRICES!"—summary shows avg/total return from portfolio.

### Updated index.html Code (Integrated Portfolio)
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=3.0, user-scalable=yes">
    <meta name="theme-color" content="#1e293b">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <title>Professional Crypto Dashboard</title>
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    <link rel="icon" href="icon-192.png">
    <style>
        /* Existing styles unchanged for brevity */
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">💰 Professional Profit Maximization Dashboard</h1>
            <p class="subtitle">Advanced Profit-Taking + Position Rotation Analytics</p>
            <div class="status" id="statusIndicator">
                <div class="status-dot"></div>
                <span id="statusText">Connecting to live market data...</span>
            </div>
            <button class="refresh-btn" id="refreshBtn">🔄 Refresh Live Data</button>
        </div>
        
        <div id="summarySection" class="summary"></div>
        
        <div id="rotationSection"></div>
        
        <div class="grid" id="cryptoGrid">
            <!-- Cards will be generated here -->
        </div>
        
        <div class="footer">
            <div>💰 Professional Profit Maximization & Rotation Analytics</div>
            <div id="lastUpdate">Last Updated: Loading...</div>
        </div>
    </div>

    <script>
        // Global variables
        let cryptoData = [];
        let currentPrices = {};
        let priceChanges = {};
        let apiStatus = 'connecting';
        let lastFetchTime = null;
        let isLoading = false;
        const coinmarketcapApiKey = 'your_api_key_here'; // Replace with your CoinMarketCap API key

        // Updated crypto configuration with your portfolio (TPs 1.5-4.5x entry, rotate for cryptos)
        const cryptoConfig = [
            { symbol: 'XRP', name: 'XRP', basePrice: 3.08, tp1: 4.62, tp2: 9.24, tp3: 13.86, coingeckoId: 'ripple', risk: 'MEDIUM', historicalLow: 0.15, historicalATH: 3.40, rotate: true },
            { symbol: 'ETH', name: 'Ethereum', basePrice: 3658.06, tp1: 5487.09, tp2: 10974.18, tp3: 16461.27, coingeckoId: 'ethereum', risk: 'LOW', historicalLow: 880, historicalATH: 4878, rotate: true },
            { symbol: 'LINK', name: 'Chainlink', basePrice: 17.75, tp1: 26.625, tp2: 53.25, tp3: 79.875, coingeckoId: 'chainlink', risk: 'MEDIUM', historicalLow: 5.50, historicalATH: 52.70, rotate: true },
            { symbol: 'ADA', name: 'Cardano', basePrice: 0.79, tp1: 1.185, tp2: 2.37, tp3: 3.555, coingeckoId: 'cardano', risk: 'MEDIUM', historicalLow: 0.25, historicalATH: 3.09, rotate: true },
            { symbol: 'SOL', name: 'Solana', basePrice: 182.16, tp1: 273.24, tp2: 546.48, tp3: 819.72, coingeckoId: 'solana', risk: 'HIGH', historicalLow: 13, historicalATH: 293.31, rotate: true },
            { symbol: 'VET', name: 'VeChain', basePrice: 0.03, tp1: 0.045, tp2: 0.09, tp3: 0.135, coingeckoId: 'vechain', risk: 'HIGH', historicalLow: 0.01, historicalATH: 0.281, rotate: true },
            { symbol: 'SUI', name: 'Sui', basePrice: 3.82, tp1: 5.73, tp2: 11.46, tp3: 17.19, coingeckoId: 'sui', risk: 'HIGH', historicalLow: 0.50, historicalATH: 5.35, rotate: true },
            { symbol: 'FARTBOY', name: 'Fartboy', basePrice: 0.02, tp1: 0.03, tp2: 0.06, tp3: 0.09, coingeckoId: 'fartboy', risk: 'HIGH', historicalLow: 0.01, historicalATH: 0.03, rotate: true }
        };

        // Portfolio values from example (for weighted avg/total profit)
        const portfolioValues = {
            'XRP': 84743.53,
            'ETH': 26030.77,
            'LINK': 22830.31,
            'ADA': 22057.99,
            'SOL': 19014.51,
            'VET': 14664.91,
            'SUI': 9850.91,
            'FARTBOY': 4715.61
        };

        // Total portfolio value
        const totalPortfolioValue = Object.values(portfolioValues).reduce((sum, val) => sum + val, 0);

        // Initialize with current prices
        function initializePrices() {
            cryptoConfig.forEach(crypto => {
                currentPrices[crypto.symbol] = crypto.basePrice;
                priceChanges[crypto.symbol] = (Math.random() - 0.3) * 10; // Realistic 24h changes
            });
        }

        // Fetch live prices from CoinMarketCap API (replace with your key)
        async function fetchLivePrices() {
            try {
                const url = 'https://pro-api.coinmarketcap.com/v2/cryptocurrency/quotes/latest?symbol=' + cryptoConfig.map(c => c.symbol).join(',');
                const response = await fetch(url, {
                    headers: {
                        'X-CMC_PRO_API_KEY': coinmarketcapApiKey,
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const data = await response.json();
                let updated = false;
                
                cryptoConfig.forEach(crypto => {
                    const coinData = data.data[crypto.symbol][0];
                    if (coinData) {
                        currentPrices[crypto.symbol] = coinData.quote.USD.price;
                        priceChanges[crypto.symbol] = coinData.quote.USD.percent_change_24h;
                        updated = true;
                    }
                });
                
                if (updated) {
                    apiStatus = 'live-data';
                    lastFetchTime = new Date();
                    console.log('✅ Successfully fetched LIVE PRICES!', currentPrices);
                    return true;
                }
            } catch (error) {
                console.log('❌ CMC fetch failed:', error.message);
            }
            
            // Fallback to demo mode
            console.log('🔄 Using enhanced demo mode');
            apiStatus = 'demo-mode';
            const priceVariations = {
                'XRP': { min: 2.9, max: 3.1, volatility: 0.04 },
                'ETH': { min: 3600, max: 3700, volatility: 0.03 },
                'LINK': { min: 17, max: 18, volatility: 0.03 },
                'ADA': { min: 0.78, max: 0.82, volatility: 0.04 },
                'SOL': { min: 180, max: 185, volatility: 0.04 },
                'VET': { min: 0.029, max: 0.031, volatility: 0.05 },
                'SUI': { min: 3.8, max: 3.9, volatility: 0.04 },
                'FARTBOY': { min: 0.019, max: 0.021, volatility: 0.05 }
            };
            cryptoConfig.forEach(crypto => {
                const variation = priceVariations[crypto.symbol];
                const randomPrice = variation.min + (Math.random() * (variation.max - variation.min));
                currentPrices[crypto.symbol] = randomPrice;
                priceChanges[crypto.symbol] = (Math.random() - 0.35) * 13;
            });
            lastFetchTime = new Date();
            return false;
        }

        // Fetch historical data for charts
        async function fetchHistoricalPrices(coingeckoId) {
            try {
                const baseUrl = `https://pro-api.coinmarketcap.com/v2/cryptocurrency/ohlcv/historical?symbol=${coingeckoId}&time_period=daily&count=30`;
                const response = await fetch(baseUrl, {
                    headers: {
                        'X-CMC_PRO_API_KEY': coinmarketcapApiKey,
                        'Accept': 'application/json'
                    }
                });
                if (!response.ok) throw new Error('Failed to fetch historical data');
                const data = await response.json();
                return data.data[coingeckoId][0].quotes.map(q => ({ time: q.timestamp, price: q.quote.USD.close }));
            } catch (error) {
                console.log('Historical fetch failed for ' + coingeckoId + ', using demo data');
                const crypto = cryptoConfig.find(c => c.coingeckoId === coingeckoId);
                let price = crypto.basePrice;
                return Array.from({length: 30}, (_, i) => {
                    price += (Math.random() - 0.5) * crypto.basePrice * 0.1;
                    return { time: Date.now() - i * 86400000, price: Math.max(crypto.basePrice * 0.5, price) };
                });
            }
        }

        // Draw chart with Canvas
        async function drawChart(symbol, canvasId) {
            const crypto = cryptoConfig.find(c => c.symbol === symbol);
            const historical = await fetchHistoricalPrices(crypto.symbol);
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.parentElement.offsetWidth - 40;
            canvas.height = 150;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const prices = historical.map(h => h.price);
            let minPrice = Math.min(...prices);
            let maxPrice = Math.max(...prices);
            const priceRange = maxPrice - minPrice || 1;
            minPrice -= priceRange * 0.1;
            maxPrice += priceRange * 0.1;
            const chartRange = maxPrice - minPrice;

            const paddingX = 10;
            ctx.beginPath();
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 2;
            historical.forEach((point, i) => {
                const x = paddingX + (i / (historical.length - 1)) * (canvas.width - 2 * paddingX);
                const y = canvas.height - ((point.price - minPrice) / chartRange) * canvas.height;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            const fibRatios = [1.272, 1.618, 2.618];
            const fibLevels = fibRatios.map(r => crypto.historicalATH + (crypto.historicalATH - crypto.historicalLow) * (r - 1));
            ctx.setLineDash([5, 5]);
            fibLevels.forEach((level, i) => {
                let y = canvas.height - ((level - minPrice) / chartRange) * canvas.height;
                const colors = ['#fbbf24', '#10b981', '#8b5cf6'][i];
                ctx.strokeStyle = colors;
                ctx.fillStyle = colors;
                ctx.font = '10px Arial';
                const precision = level < 1 ? 4 : (level < 10 ? 2 : 0);
                const label = `Fib ${fibRatios[i]}: ${level.toFixed(precision)}`;
                if (y > canvas.height) {
                    y = canvas.height;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    ctx.fillText(label + ' (below)', paddingX, y - 5);
                } else if (y < 0) {
                    y = 0;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    ctx.fillText(label + ' (above)', paddingX, y + 15);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                    let labelY = y - 5;
                    if (labelY < 10) labelY = 15;
                    if (labelY > canvas.height - 10) labelY = canvas.height - 15;
                    ctx.fillText(label, paddingX, labelY);
                }
            });
            ctx.setLineDash([]);
        }

        function updateDemoPrices() {
            if (apiStatus === 'demo-mode') {
                cryptoConfig.forEach(crypto => {
                    const currentPrice = currentPrices[crypto.symbol];
                    const movement = (Math.random() - 0.5) * 0.01;
                    currentPrices[crypto.symbol] = currentPrice * (1 + movement);
                    priceChanges[crypto.symbol] += (Math.random() - 0.5) * 0.5;
                });
            }
        }

        function getRandomTechnicals() {
            const recommendations = ['STRONG BUY', 'BUY', 'HOLD', 'WEAK SELL'];
            const trends = ['BULLISH', 'BEARISH', 'NEUTRAL'];
            const patterns = ['BULLISH_IM
